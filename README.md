# vectup
Template that can hold either an array (fixed size), vector, or tuple.  Zip and fold defined to allow access.  C++14 only.

Defined in the namespace uniformcoll

One struct defined: `vectup<storage_type, types...>`

1. If storage_type is `staticalloc`, types is a list of the types to be stored in order (essentially a tuple)
2. If storage_type is `dynamicalloc`, types must be a single element and the struct stores a dynamic number of them (essentially a vector)
3. If storage_type is a non-negative `int`, types must be a single element and the struct stores that number of that type (essentially a statically allocated array)

* In the first and third case, the struct may be used in constexpr operations.
* In the last two cases, the struct defines iterators and the like for normal access
* In all cases, the struct defines a templated *member* function `get` that allows access (consistent with a general tuple, but as a member function):
```
uniformcoll::vectup<uniformcoll::dynamicalloc,char> vt;
// ... code to fill up vt ...
char c = vt::template get<2>(); // returns the 3rd (0-indexed) item in the vector
```
and defines `.front()` and `.back()`.

Four operations defined:

1. `zip(f,vt1,vt2)`: f is an object with the `operator()(a,b)` defined for all types of `a` and `b` necessary during use. `vt1` and `vt2` are any two `vectup` (their storages may be different or the same).  `zip` returns a `vectup` in which each element with index `i` is generated by calling `f` with element with index `i` from `vt1` and element with index `i` from `vt2` (`a` is the element from `vt1` and `b` is the element from `vt2`).  The length of the returned object is the smaller of the lengths of `vt1` and `vt2` EXCEPT if one is allocated dynamically and the other is allocated statically (ie one if a vector and the other is a tuple).  In this case, it is the size of the statically allocated one (and the dynamically-allocated one must be of at least this length at run tim).  This is to make sure that the type of the result can be deduced at compile-time.  Note that if the compiler can deduce that the returned collection is homogeneous (in type), it will use a static array instead of a tuple.
2. `foldl(f,x0,vt)`: f is an object with the `operator()(a,b)` defined for all types of `a` and `b` necessary during use.  `vt` is a `vectup` (of any type).  `x0` is a variable of the necessary type.  This implements the classic foldl function in which the result (or `x0` to begin) is passed as `a` into `f` and the element from the `vt` is passed as `b`.
3. `foldr(f,x0,vt)`: same as `foldl`, but for foldr functionality.  However, in this case the element from `vt` is passed in as `a` and the result (or `x0`) as `b`.
4. `foldrflip(f,x0,vt)`: same as `foldr` but the arguments to `f` are passed in the reverse order.

Note that these functions are all `constexpr` but passing in a lambda function for f currently (as of C++14) renders them non-`constexpr` (and thus you have to construct the struct explicitly).  Hopefully this will be fixed in C++17.
